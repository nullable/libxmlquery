
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Data Structures &mdash; libxmlquery v0.1.4 documentation</title>
    <link rel="stylesheet" href="../lxq_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../lxq_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.1.4',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../lxq_static/jquery.js"></script>
    <script type="text/javascript" src="../lxq_static/underscore.js"></script>
    <script type="text/javascript" src="../lxq_static/doctools.js"></script>
    <link rel="top" title="libxmlquery v0.1.4 documentation" href="../index.html" />
    <link rel="next" title="Special Macros" href="../macros.h.html" />
    <link rel="prev" title="Querying" href="../querying.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../macros.h.html" title="Special Macros"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="../querying.html" title="Querying"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">libxmlquery v0.1.4 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="data-structures">
<h1>Data Structures<a class="headerlink" href="#data-structures" title="Permalink to this headline">¶</a></h1>
<div class="section" id="generic-list">
<h2>Generic List<a class="headerlink" href="#generic-list" title="Permalink to this headline">¶</a></h2>
<p>Generic array list optimized for fast access. This structure is defined in stack.h and implemented in stack.c. It can act as a stack, queue or random access list. Although they seem different, the datastructure is the same and every function of one type can be used in another. This means that you can have a random access list and start poping out elements as though it was a stack.</p>
<dl class="type">
<dt id="generic_list_s">
struct <tt class="descname">generic_list_s</tt><a class="headerlink" href="#generic_list_s" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="type">
<dt id="list">
<tt class="descname">list</tt><a class="headerlink" href="#list" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>This structure defines the random access list. Its structure definition is:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">generic_list_s</span><span class="p">{</span>
  <span class="k">struct</span> <span class="n">list_bucket</span><span class="o">**</span> <span class="n">array</span><span class="p">;</span>
  <span class="kt">int32_t</span> <span class="n">start</span><span class="p">;</span>
  <span class="kt">int32_t</span> <span class="n">count</span><span class="p">;</span>
  <span class="kt">int32_t</span> <span class="n">capacity</span><span class="p">;</span>
<span class="p">}</span> <span class="n">list</span><span class="p">;</span>
</pre></div>
</div>
<p>As you can see this is just a list backed up by an array of <tt class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">list_bucket</span></tt>. These buckets are defined as follows:</p>
<dl class="type">
<dt id="list_bucket">
struct <tt class="descname">list_bucket</tt><a class="headerlink" href="#list_bucket" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="highlight-c"><div class="highlight"><pre><span class="k">struct</span> <span class="n">list_bucket</span>
<span class="p">{</span>
  <span class="kt">int16_t</span> <span class="n">type</span><span class="p">;</span>
  <span class="kt">void</span><span class="o">*</span> <span class="n">element</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Finally, notice that the stack and queue type are just typedefs of <a class="reference internal" href="#list" title="list"><tt class="xref c c-type docutils literal"><span class="pre">list</span></tt></a>.</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">generic_list_s</span> <span class="n">stack</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">generic_list_s</span> <span class="n">queue</span><span class="p">;</span>
</pre></div>
</div>
<p>The next sections will show how to use these types.</p>
<div class="section" id="function-description">
<h3>Function description<a class="headerlink" href="#function-description" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="generic_list_is_empty">
uint8_t <tt class="descname">generic_list_is_empty</tt><big>(</big>struct <a class="reference internal" href="#generic_list_s" title="generic_list_s">generic_list_s</a>*<em> l</em><big>)</big><a class="headerlink" href="#generic_list_is_empty" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="xref c c-member docutils literal"><span class="pre">l</span></tt> The generic list to check if is empty.</p>
<p>This function checks if the generic list is empty. It return an integer bigger than 0 if true, or 0 if false.</p>
</dd></dl>

<dl class="function">
<dt id="generic_list_get_count">
int32_t <tt class="descname">generic_list_get_count</tt><big>(</big>struct <a class="reference internal" href="#generic_list_s" title="generic_list_s">generic_list_s</a>*<em> l</em><big>)</big><a class="headerlink" href="#generic_list_get_count" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="xref c c-member docutils literal"><span class="pre">l</span></tt> The generic list to obtain the count of elements.</p>
<p>This function return the number of elements in the generic list.</p>
</dd></dl>

<dl class="function">
<dt id="new_generic_list">
struct <a class="reference internal" href="#generic_list_s" title="generic_list_s">generic_list_s</a> *<tt class="descname">new_generic_list</tt><big>(</big>int32_t<em> initial</em><big>)</big><a class="headerlink" href="#new_generic_list" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="xref c c-member docutils literal"><span class="pre">initial</span></tt> Initial capcity for a generic list.</p>
<p>This function returns a generic list with a given initial capacity. Capacity dictates how much space the list will take. You don&#8217;t need to
worry about reallocation, but consider using small values for capacity when you know that the list will not grow that much.</p>
</dd></dl>

<dl class="function">
<dt id="new_stack">
stack* <tt class="descname">new_stack</tt><big>(</big>int32_t<em> initial</em><big>)</big><a class="headerlink" href="#new_stack" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="xref c c-member docutils literal"><span class="pre">initial</span></tt> Initial capcity for a stack.</p>
<p>This function is just an alias for <a class="reference internal" href="#new_generic_list" title="new_generic_list"><tt class="xref c c-func docutils literal"><span class="pre">new_generic_list()</span></tt></a>.</p>
</dd></dl>

<dl class="function">
<dt id="new_queue">
queue* <tt class="descname">new_queue</tt><big>(</big>int32_t<em> initial</em><big>)</big><a class="headerlink" href="#new_queue" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="xref c c-member docutils literal"><span class="pre">initial</span></tt> Initial capcity for a queue.</p>
<p>This function is just an alias for <a class="reference internal" href="#new_generic_list" title="new_generic_list"><tt class="xref c c-func docutils literal"><span class="pre">new_generic_list()</span></tt></a>.</p>
</dd></dl>

<dl class="function">
<dt id="set_element_with_type_at">
void* <tt class="descname">set_element_with_type_at</tt><big>(</big><a class="reference internal" href="#list" title="list">list</a><em> *l</em>, void*<em> obj</em>, int16_t<em> type</em>, int32_t<em> pos</em><big>)</big><a class="headerlink" href="#set_element_with_type_at" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="xref c c-member docutils literal"><span class="pre">l</span></tt> List where to set the element.</p>
<p><tt class="xref c c-member docutils literal"><span class="pre">obj</span></tt> New element to store in the list.</p>
<p><tt class="xref c c-member docutils literal"><span class="pre">type</span></tt> The type of the new element.</p>
<p><tt class="xref c c-member docutils literal"><span class="pre">pos</span></tt> The position of the element to be set.</p>
<p>This function sets an already exiting element to a new one. A pointer to the old one is returned so the user can free the space used by it.</p>
</dd></dl>

<dl class="function">
<dt id="set_element_at">
void* <tt class="descname">set_element_at</tt><big>(</big><a class="reference internal" href="#list" title="list">list</a><em> *l</em>, void*<em> obj</em>, int32_t<em> pos</em><big>)</big><a class="headerlink" href="#set_element_at" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="xref c c-member docutils literal"><span class="pre">l</span></tt> List where to set the element.</p>
<p><tt class="xref c c-member docutils literal"><span class="pre">obj</span></tt> New element to store in the list.</p>
<p><tt class="xref c c-member docutils literal"><span class="pre">pos</span></tt> The position of the element to be set.</p>
<p>This function does exactly the same as <a class="reference internal" href="#set_element_with_type_at" title="set_element_with_type_at"><tt class="xref c c-func docutils literal"><span class="pre">set_element_with_type_at()</span></tt></a>, but without the type feature.</p>
</dd></dl>

<dl class="function">
<dt id="insert_element_with_type_at">
void <tt class="descname">insert_element_with_type_at</tt><big>(</big><a class="reference internal" href="#list" title="list">list</a>*<em> l</em>, void*<em> obj</em>, int16_t<em> type</em>, int32_t<em> pos</em><big>)</big><a class="headerlink" href="#insert_element_with_type_at" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="xref c c-member docutils literal"><span class="pre">l</span></tt> List where to insert the element.</p>
<p><tt class="xref c c-member docutils literal"><span class="pre">obj</span></tt> New element to store in the list.</p>
<p><tt class="xref c c-member docutils literal"><span class="pre">type</span></tt> The type of the new element.</p>
<p><tt class="xref c c-member docutils literal"><span class="pre">pos</span></tt> The position of the element to be set.</p>
<p>This function inserts an element at a given position with a given type. The list will be resized if necessary.</p>
</dd></dl>

<dl class="function">
<dt id="insert_element_at">
void <tt class="descname">insert_element_at</tt><big>(</big><a class="reference internal" href="#list" title="list">list</a>*<em> l</em>, void*<em> obj</em>, int32_t<em> pos</em><big>)</big><a class="headerlink" href="#insert_element_at" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="xref c c-member docutils literal"><span class="pre">l</span></tt> List where to insert the element.</p>
<p><tt class="xref c c-member docutils literal"><span class="pre">obj</span></tt> New element to store in the list.</p>
<p><tt class="xref c c-member docutils literal"><span class="pre">pos</span></tt> The position of the element to be set.</p>
<p>This function does exactly the same thing as <a class="reference internal" href="#insert_element_with_type_at" title="insert_element_with_type_at"><tt class="xref c c-func docutils literal"><span class="pre">insert_element_with_type_at()</span></tt></a>, but without the type feature.</p>
</dd></dl>

<dl class="function">
<dt id="sorted_insert_element_with_type">
void <tt class="descname">sorted_insert_element_with_type</tt><big>(</big><a class="reference internal" href="#list" title="list">list</a>*<em> l</em>, void*<em> obj</em>, int16_t<em> type</em>, int(*compare)(void*<em> o1</em>, int16_t<em> type1</em>, void*<em> o2</em>, int16_t<em> type2)</em><big>)</big><a class="headerlink" href="#sorted_insert_element_with_type" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="xref c c-member docutils literal"><span class="pre">l</span></tt> List where to insert the element.</p>
<p><tt class="xref c c-member docutils literal"><span class="pre">obj</span></tt> New element to store in the list.</p>
<p><tt class="xref c c-member docutils literal"><span class="pre">type</span></tt> The type of the new element.</p>
<p><tt class="xref c c-member docutils literal"><span class="pre">compare</span></tt> A function pointer to a function that compares elements in the list.</p>
<p>This function inserts an element into a list in sorted order, according to the function pointer passed as an argument.</p>
</dd></dl>

<dl class="function">
<dt id="append_element">
void <tt class="descname">append_element</tt><big>(</big><a class="reference internal" href="#list" title="list">list</a>*<em> l</em>, void*<em> obj</em>, int16_t<em> type</em><big>)</big><a class="headerlink" href="#append_element" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="xref c c-member docutils literal"><span class="pre">l</span></tt> List where to append the element.</p>
<p><tt class="xref c c-member docutils literal"><span class="pre">obj</span></tt> New element to store in the list.</p>
<p><tt class="xref c c-member docutils literal"><span class="pre">type</span></tt> The type of the new element.</p>
<p>This function inserts an element at the end of the list.</p>
</dd></dl>

<dl class="function">
<dt id="prepend_element">
void <tt class="descname">prepend_element</tt><big>(</big><a class="reference internal" href="#list" title="list">list</a>*<em> l</em>, void*<em> obj</em>, int16_t<em> type</em><big>)</big><a class="headerlink" href="#prepend_element" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="xref c c-member docutils literal"><span class="pre">l</span></tt> List where to prepend the element.</p>
<p><tt class="xref c c-member docutils literal"><span class="pre">obj</span></tt> New element to store in the list.</p>
<p><tt class="xref c c-member docutils literal"><span class="pre">type</span></tt> The type of the new element.</p>
<p>This function inserts an element at the beginning of the list.</p>
</dd></dl>

<dl class="function">
<dt id="add_element_with_type">
void <tt class="descname">add_element_with_type</tt><big>(</big><a class="reference internal" href="#list" title="list">list</a>*<em> l</em>, void*<em> obj</em>, int16_t<em> type</em><big>)</big><a class="headerlink" href="#add_element_with_type" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="xref c c-member docutils literal"><span class="pre">l</span></tt> List where to add the element.</p>
<p><tt class="xref c c-member docutils literal"><span class="pre">obj</span></tt> New element to store in the list.</p>
<p><tt class="xref c c-member docutils literal"><span class="pre">type</span></tt> The type of the new element.</p>
<p>This function adds an element to a list. It differs from <a class="reference internal" href="#prepend_element" title="prepend_element"><tt class="xref c c-func docutils literal"><span class="pre">prepend_element()</span></tt></a> and <a class="reference internal" href="#append_element" title="append_element"><tt class="xref c c-func docutils literal"><span class="pre">append_element()</span></tt></a> in the sense that the user doesn&#8217;t need to know
Where the element will be added.</p>
</dd></dl>

<dl class="function">
<dt id="add_element">
void <tt class="descname">add_element</tt><big>(</big><a class="reference internal" href="#list" title="list">list</a>*<em> l</em>, void*<em> obj</em><big>)</big><a class="headerlink" href="#add_element" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="xref c c-member docutils literal"><span class="pre">l</span></tt> List where to add the element.</p>
<p><tt class="xref c c-member docutils literal"><span class="pre">obj</span></tt> New element to store in the list.</p>
<p>This function is exactly the same as <a class="reference internal" href="#add_element_with_type" title="add_element_with_type"><tt class="xref c c-func docutils literal"><span class="pre">add_element_with_type()</span></tt></a>, but without the type feature.</p>
</dd></dl>

<dl class="function">
<dt id="get_element_at">
void* <tt class="descname">get_element_at</tt><big>(</big>const <a class="reference internal" href="#list" title="list">list</a>*<em> l</em>, int32_t<em> pos</em><big>)</big><a class="headerlink" href="#get_element_at" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="xref c c-member docutils literal"><span class="pre">l</span></tt> List from where to get the element.</p>
<p><tt class="xref c c-member docutils literal"><span class="pre">pos</span></tt> The element&#8217;s position.</p>
<p>This function returns the element stored at the given position.</p>
</dd></dl>

<dl class="function">
<dt id="get_element_and_type_at">
void* <tt class="descname">get_element_and_type_at</tt><big>(</big>const <a class="reference internal" href="#list" title="list">list</a>*<em> l</em>, int32_t<em> pos</em>, int16_t*<em> type</em><big>)</big><a class="headerlink" href="#get_element_and_type_at" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="xref c c-member docutils literal"><span class="pre">l</span></tt> List from where to get the element.</p>
<p><tt class="xref c c-member docutils literal"><span class="pre">pos</span></tt> The element&#8217;s position.</p>
<p><tt class="xref c c-member docutils literal"><span class="pre">type</span></tt> An address to store the elements type.</p>
<p>This function does the same as <a class="reference internal" href="#get_element_at" title="get_element_at"><tt class="xref c c-func docutils literal"><span class="pre">get_element_at()</span></tt></a>, but it also returns the element&#8217;s type. This is stored in a location passed as the third argument
to this function.</p>
</dd></dl>

<dl class="function">
<dt id="get_element_pos">
int <tt class="descname">get_element_pos</tt><big>(</big>const <a class="reference internal" href="#list" title="list">list</a>*<em> l</em>, void*<em> el</em><big>)</big><a class="headerlink" href="#get_element_pos" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="xref c c-member docutils literal"><span class="pre">l</span></tt> List from where to get the element&#8217;s position.</p>
<p><tt class="xref c c-member docutils literal"><span class="pre">el</span></tt> The element to look for in the list.</p>
<p>This function returns the position of the element passed as an argument. If no element is found, then -1 is returned.</p>
</dd></dl>

<dl class="function">
<dt id="remove_element">
int32_t <tt class="descname">remove_element</tt><big>(</big><a class="reference internal" href="#list" title="list">list</a><em> *l</em>, void*<em> obj</em><big>)</big><a class="headerlink" href="#remove_element" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="xref c c-member docutils literal"><span class="pre">l</span></tt> List from where to remove the element.</p>
<p><tt class="xref c c-member docutils literal"><span class="pre">obj</span></tt> The element to be removed.</p>
<p>This function removes the first occurrence of a given element from a list. If the element doesn&#8217;t exist then nothing will happen.</p>
</dd></dl>

<dl class="function">
<dt id="remove_all">
int32_t <tt class="descname">remove_all</tt><big>(</big><a class="reference internal" href="#list" title="list">list</a><em> *l</em>, void*<em> obj</em><big>)</big><a class="headerlink" href="#remove_all" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="xref c c-member docutils literal"><span class="pre">l</span></tt> List from where to remove the element.</p>
<p><tt class="xref c c-member docutils literal"><span class="pre">obj</span></tt> The element to be removed.</p>
<p>This function removes all occurrences of a given element from a list. If no element is found then nothing will happen.</p>
</dd></dl>

<dl class="function">
<dt id="remove_element_at">
void* <tt class="descname">remove_element_at</tt><big>(</big><a class="reference internal" href="#list" title="list">list</a>*<em> l</em>, int32_t<em> pos</em><big>)</big><a class="headerlink" href="#remove_element_at" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="xref c c-member docutils literal"><span class="pre">l</span></tt> List from where to remove the element.</p>
<p><tt class="xref c c-member docutils literal"><span class="pre">pos</span></tt> Position of the element to be removed.</p>
<p>This function removes the element at a given position from a list.</p>
</dd></dl>

<dl class="function">
<dt id="enqueue_with_type">
void <tt class="descname">enqueue_with_type</tt><big>(</big>queue*<em> q</em>, void*<em> obj</em>, int16_t<em> type</em><big>)</big><a class="headerlink" href="#enqueue_with_type" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="xref c c-member docutils literal"><span class="pre">q</span></tt> Queue where to enqueue the element.</p>
<p><tt class="xref c c-member docutils literal"><span class="pre">obj</span></tt> Element to enqueue.</p>
<p><tt class="xref c c-member docutils literal"><span class="pre">type</span></tt> The type of the element being enqueued.</p>
<p>This function enqueues an element with a given type in a given queue.</p>
</dd></dl>

<dl class="function">
<dt id="enqueue">
void <tt class="descname">enqueue</tt><big>(</big>queue*<em> q</em>, void*<em> obj</em><big>)</big><a class="headerlink" href="#enqueue" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="xref c c-member docutils literal"><span class="pre">q</span></tt> Queue where to enqueue the element.</p>
<p><tt class="xref c c-member docutils literal"><span class="pre">obj</span></tt> Element to enqueue.</p>
<p>This function is the same as <a class="reference internal" href="#enqueue_with_type" title="enqueue_with_type"><tt class="xref c c-func docutils literal"><span class="pre">enqueue_with_type()</span></tt></a>, but without the type feature.</p>
</dd></dl>

<dl class="function">
<dt id="dequeue">
void* <tt class="descname">dequeue</tt><big>(</big>queue*<em> q</em><big>)</big><a class="headerlink" href="#dequeue" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="xref c c-member docutils literal"><span class="pre">q</span></tt> Queue from where to dequeue an element.</p>
<p>This function dequeues an element from a given queue. If no element is present, then NULL is returned.</p>
</dd></dl>

<dl class="function">
<dt id="push_stack_type">
void <tt class="descname">push_stack_type</tt><big>(</big>stack*<em> s</em>, void*<em> obj</em>, int16_t<em> type</em><big>)</big><a class="headerlink" href="#push_stack_type" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="xref c c-member docutils literal"><span class="pre">s</span></tt> Stack where to push the element.</p>
<p><tt class="xref c c-member docutils literal"><span class="pre">obj</span></tt> Element to push onto the stack.</p>
<p><tt class="xref c c-member docutils literal"><span class="pre">type</span></tt> The type of the element being push.</p>
<p>This function pushes an element with a given type onto a given stack.</p>
</dd></dl>

<dl class="function">
<dt id="push_stack">
void <tt class="descname">push_stack</tt><big>(</big>stack*<em> s</em>, void*<em> obj</em><big>)</big><a class="headerlink" href="#push_stack" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="xref c c-member docutils literal"><span class="pre">s</span></tt> Stack where to push the element.</p>
<p><tt class="xref c c-member docutils literal"><span class="pre">obj</span></tt> Element to push onto the stack.</p>
<p>This function is the same as <a class="reference internal" href="#push_stack_type" title="push_stack_type"><tt class="xref c c-func docutils literal"><span class="pre">push_stack_type()</span></tt></a>, but without the type feature.</p>
</dd></dl>

<dl class="function">
<dt id="pop_stack">
void* <tt class="descname">pop_stack</tt><big>(</big>stack*<em> s</em><big>)</big><a class="headerlink" href="#pop_stack" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="xref c c-member docutils literal"><span class="pre">s</span></tt> Stack from where to pop an element.</p>
<p>This function pops an element from a given stack. If no element is present, NULL is returned.</p>
</dd></dl>

<dl class="function">
<dt id="remove_duplicates">
<a class="reference internal" href="#list" title="list">list</a>* <tt class="descname">remove_duplicates</tt><big>(</big><a class="reference internal" href="#list" title="list">list</a>*<em> l</em><big>)</big><a class="headerlink" href="#remove_duplicates" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="xref c c-member docutils literal"><span class="pre">l</span></tt> List from where to remove duplicate elements.</p>
<p>This function removes duplicate values based on their memory address.</p>
</dd></dl>

<dl class="function">
<dt id="peek_element_type_at">
int16_t <tt class="descname">peek_element_type_at</tt><big>(</big><a class="reference internal" href="#list" title="list">list</a>*<em> l</em>, int32_t<em> pos</em><big>)</big><a class="headerlink" href="#peek_element_type_at" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="xref c c-member docutils literal"><span class="pre">l</span></tt> List from where to peek an element&#8217;s type.</p>
<p><tt class="xref c c-member docutils literal"><span class="pre">pos</span></tt> The element&#8217;s position in the list.</p>
<p>This function lets you see which type the element at a given position has. If no element is in that position the program will exit.</p>
</dd></dl>

<dl class="function">
<dt id="peek_stack_type">
int16_t <tt class="descname">peek_stack_type</tt><big>(</big>stack<em> *s</em><big>)</big><a class="headerlink" href="#peek_stack_type" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="xref c c-member docutils literal"><span class="pre">s</span></tt> Stack from where to peek the element&#8217;s type.</p>
<p>This function is the same as <a class="reference internal" href="#peek_element_type_at" title="peek_element_type_at"><tt class="xref c c-func docutils literal"><span class="pre">peek_element_type_at()</span></tt></a>, but it applies only to stacks. This means that it will only check the element at the head of the stack.</p>
</dd></dl>

<dl class="function">
<dt id="peek_queue_type">
int16_t <tt class="descname">peek_queue_type</tt><big>(</big>queue<em> *s</em><big>)</big><a class="headerlink" href="#peek_queue_type" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="xref c c-member docutils literal"><span class="pre">s</span></tt> Queue from where to peek the element&#8217;s type.</p>
<p>This function is the same as <a class="reference internal" href="#peek_stack_type" title="peek_stack_type"><tt class="xref c c-func docutils literal"><span class="pre">peek_stack_type()</span></tt></a>. However, it applies only to queues.</p>
</dd></dl>

<dl class="function">
<dt id="merge_lists">
struct <a class="reference internal" href="#generic_list_s" title="generic_list_s">generic_list_s</a> *<tt class="descname">merge_lists</tt><big>(</big>struct <a class="reference internal" href="#generic_list_s" title="generic_list_s">generic_list_s</a><em> *l1</em>, struct <a class="reference internal" href="#generic_list_s" title="generic_list_s">generic_list_s</a><em> *l2</em><big>)</big><a class="headerlink" href="#merge_lists" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="xref c c-member docutils literal"><span class="pre">l1</span></tt> Any list.</p>
<p><tt class="xref c c-member docutils literal"><span class="pre">l2</span></tt> Any list.</p>
<p>This function merges two list onto a single one. The list l2 will be append to l1. Beware that the input lists will be destroyed. The merged list is returned. If
both lists are NULL, then NULL is returned.</p>
</dd></dl>

<dl class="function">
<dt id="duplicate_generic_list">
struct <a class="reference internal" href="#generic_list_s" title="generic_list_s">generic_list_s</a> *<tt class="descname">duplicate_generic_list</tt><big>(</big>const struct<em> generic_list_s*</em><big>)</big><a class="headerlink" href="#duplicate_generic_list" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="xref c c-member docutils literal"><span class="pre">s</span></tt> List to be duplicated.</p>
<p>This function allocates and fills a new list with the same values as the given list. Only the buckets are duplicated, the elements on the list stay exactly the same.</p>
</dd></dl>

<dl class="function">
<dt id="destroy_generic_list">
void <tt class="descname">destroy_generic_list</tt><big>(</big>struct <a class="reference internal" href="#generic_list_s" title="generic_list_s">generic_list_s</a><em> *s</em><big>)</big><a class="headerlink" href="#destroy_generic_list" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="xref c c-member docutils literal"><span class="pre">s</span></tt> List to be destroyed</p>
<p>This function destroys a given list. Only the buckets get destroyed, the elements must be detroyed by the user.</p>
<p>Example:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="cp">#include &lt;stdlib.h&gt;</span>
<span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &quot;stack.h&quot;</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
   <span class="n">list</span><span class="o">*</span> <span class="n">l</span> <span class="o">=</span> <span class="n">new_generic_list</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
   <span class="kt">int</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="o">*</span><span class="n">b</span><span class="p">;</span>

   <span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
   <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
   <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">a</span> <span class="o">||</span> <span class="o">!</span><span class="n">b</span><span class="p">){</span>
     <span class="n">printf</span><span class="p">(</span><span class="s">&quot;malloc failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
     <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
   <span class="p">}</span>

   <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="mi">9</span><span class="p">;</span>
   <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>

   <span class="n">append_element</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
   <span class="n">append_element</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

   <span class="n">generic_list_iterator</span><span class="o">*</span> <span class="n">it</span> <span class="o">=</span> <span class="n">new_generic_list_iterator</span><span class="p">(</span><span class="n">l</span><span class="p">);</span>
   <span class="k">while</span><span class="p">(</span><span class="n">generic_list_iterator_has_next</span><span class="p">(</span><span class="n">it</span><span class="p">)){</span>
     <span class="kt">int</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span> <span class="n">generic_list_iterator_next</span><span class="p">(</span><span class="n">it</span><span class="p">);</span>
     <span class="n">free</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
   <span class="p">}</span>
   <span class="n">destroy_generic_list_iterator</span><span class="p">(</span><span class="n">it</span><span class="p">);</span>

   <span class="n">destroy_generic_list</span><span class="p">(</span><span class="n">l</span><span class="p">);</span>

   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>You may compile it with</p>
<div class="highlight-bash"><div class="highlight"><pre>gcc -o <span class="nb">test</span> &lt;above_source_file&gt; -I&lt;folder path where stack.h is kept&gt;
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="new_generic_list_iterator">
generic_list_iterator* <tt class="descname">new_generic_list_iterator</tt><big>(</big>struct <a class="reference internal" href="#generic_list_s" title="generic_list_s">generic_list_s</a>*<em> s</em><big>)</big><a class="headerlink" href="#new_generic_list_iterator" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="xref c c-member docutils literal"><span class="pre">s</span></tt> List to be iterated.</p>
<p>This function creates an iterator for the given list.</p>
</dd></dl>

<dl class="function">
<dt id="generic_list_iterator_has_next">
uint8_t <tt class="descname">generic_list_iterator_has_next</tt><big>(</big>generic_list_iterator*<em> i</em><big>)</big><a class="headerlink" href="#generic_list_iterator_has_next" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="xref c c-member docutils literal"><span class="pre">i</span></tt> A list iterator.</p>
<p>This function checks if there are elements still to be iterated. If not 0 is returned, otherwise a value different from 0 is returned.</p>
</dd></dl>

<dl class="function">
<dt id="generic_list_iterator_next">
void* <tt class="descname">generic_list_iterator_next</tt><big>(</big>generic_list_iterator*<em> i</em><big>)</big><a class="headerlink" href="#generic_list_iterator_next" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="xref c c-member docutils literal"><span class="pre">i</span></tt> A list iterator</p>
<p>This function returns an element from the list and advances the iterator to the next position.</p>
</dd></dl>

<dl class="function">
<dt id="destroy_generic_list_iterator">
void <tt class="descname">destroy_generic_list_iterator</tt><big>(</big>generic_list_iterator*<em> i</em><big>)</big><a class="headerlink" href="#destroy_generic_list_iterator" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="xref c c-member docutils literal"><span class="pre">i</span></tt> A list iterator</p>
<p>This function frees a list iterator.</p>
</dd></dl>

</div>
</div>
<div class="section" id="generic-red-black-tree">
<h2>Generic Red Black Tree<a class="headerlink" href="#generic-red-black-tree" title="Permalink to this headline">¶</a></h2>
<p>The file rbtree.c contains the source code for a generic red black tree. This data structure is capable of storing any kind of data and its defined in rbtree.h as:</p>
<dl class="type">
<dt id="tree_root">
<tt class="descname">tree_root</tt><a class="headerlink" href="#tree_root" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="type">
<dt id="sroot">
struct <tt class="descname">sroot</tt><a class="headerlink" href="#sroot" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="highlight-c"><div class="highlight"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">sroot</span><span class="p">{</span>
   <span class="k">struct</span> <span class="n">stree_node</span><span class="o">*</span> <span class="n">root</span><span class="p">;</span>
   <span class="kt">void</span><span class="o">*</span> <span class="p">(</span><span class="o">*</span><span class="n">key</span><span class="p">)(</span><span class="k">struct</span> <span class="n">stree_node</span><span class="o">*</span> <span class="n">node</span><span class="p">);</span>
   <span class="kt">int64_t</span> <span class="p">(</span><span class="o">*</span><span class="n">compare</span><span class="p">)(</span><span class="kt">void</span><span class="o">*</span> <span class="n">keyA</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">keyB</span><span class="p">);</span>
<span class="p">}</span><span class="n">tree_root</span><span class="p">;</span>
</pre></div>
</div>
<p>There are two things to notice here. First, this is only the root of the tree and points to the first tree_node of the rbtree. Second, it contains two function pointers. The first points to a function, which receives a <a class="reference internal" href="#tree_node" title="tree_node"><tt class="xref c c-type docutils literal"><span class="pre">tree_node</span></tt></a> and should return a <strong>pointer</strong> to that node&#8217;s key. The second is a pointer to a compare function, which compares two keys and should return:</p>
<ul class="simple">
<li>A negative integer if the first key is smaller than the second.</li>
<li>0 if the keys are the same.</li>
<li>A positive integer if the first key is bigger than the second.</li>
</ul>
<p>The compare function must be:</p>
<ul class="simple">
<li>Reflexive: Given an object a. compare(a, a) should always return 0.</li>
<li>Symetric: Given two identical objects a and b, if compare(a,b) returns 0, then compare(b,a) must return 0.</li>
<li>Transitive: Given three objects a, b, c. If compare(a,b) returns 0, and compare(b,c) returns 0, then compare(a,c) must return 0.</li>
<li>Consistent: Multiple invocations of compare on the same objects in the same other, must return always the same value.</li>
</ul>
<p>These properties should hold even if objects aren&#8217;t equal.</p>
<p>The compare and key function pointers must be provided by the user. Why do we need these pointers? Because the data stored in the rbtree can be anything, but we still need to know how to sort it. Nevertheless, if you wish to use this data structure as a container and don&#8217;t care how things are sorted, you can always use the method <a class="reference internal" href="#new_simple_rbtree" title="new_simple_rbtree"><tt class="xref c c-func docutils literal"><span class="pre">new_simple_rbtree()</span></tt></a>.</p>
<p>Each node in an rbtree is called a tree_node and is defined in rbtree.h as:</p>
<dl class="type">
<dt id="tree_node">
<tt class="descname">tree_node</tt><a class="headerlink" href="#tree_node" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="type">
<dt id="stree_node">
struct <tt class="descname">stree_node</tt><a class="headerlink" href="#stree_node" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="highlight-c"><div class="highlight"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">stree_node</span><span class="p">{</span>
   <span class="kt">void</span><span class="o">*</span> <span class="n">node</span><span class="p">;</span>

   <span class="kt">uint8_t</span> <span class="n">color</span><span class="p">;</span>

   <span class="k">struct</span> <span class="n">stree_node</span><span class="o">*</span> <span class="n">parent</span><span class="p">;</span>
   <span class="k">struct</span> <span class="n">stree_node</span><span class="o">*</span> <span class="n">left</span><span class="p">;</span>
   <span class="k">struct</span> <span class="n">stree_node</span><span class="o">*</span> <span class="n">right</span><span class="p">;</span>
 <span class="p">}</span><span class="n">tree_node</span><span class="p">;</span>
</pre></div>
</div>
<p>There&#8217;s not much to say about this structure, the only thing relevant is the field <tt class="docutils literal"><span class="pre">node</span></tt>, which is used to store the actual data. The other fields are used to keep the rbtree intact.</p>
<p>Finally, there&#8217;s one more structure, which is defined in rbtree.h as:</p>
<dl class="type">
<dt id="tree_iterator">
<tt class="descname">tree_iterator</tt><a class="headerlink" href="#tree_iterator" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="type">
<dt id="siterator">
struct <tt class="descname">siterator</tt><a class="headerlink" href="#siterator" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="highlight-c"><div class="highlight"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">siterator</span><span class="p">{</span>
   <span class="k">struct</span> <span class="n">stree_node</span><span class="o">*</span> <span class="n">current</span><span class="p">;</span>
<span class="p">}</span><span class="n">tree_iterator</span><span class="p">;</span>
</pre></div>
</div>
<p>As the name implies, this structure is an iterator to the tree nodes.</p>
<p>As a final note, remember that we provide functions to destroy our structures, but the actual data must be destroyed by you. Do not use iterators for this purpose.</p>
<div class="section" id="id1">
<h3>Function description<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="new_simple_rbtree">
<a class="reference internal" href="#tree_root" title="tree_root">tree_root</a>* <tt class="descname">new_simple_rbtree</tt><big>(</big><big>)</big><a class="headerlink" href="#new_simple_rbtree" title="Permalink to this definition">¶</a></dt>
<dd><p>This function creates an rbtree, which sorts the data acording to its memory pointer. This function should be used when you just want the rbtree to behave as a container,
but you still need O(log(n)) when accessing the data. Keep in mind that in order to retreive the stored data, you need to know it&#8217;s memory pointer.</p>
<p>The return value is a tree_root structure.</p>
</dd></dl>

<dl class="function">
<dt id="new_rbtree">
<a class="reference internal" href="#tree_root" title="tree_root">tree_root</a>* <tt class="descname">new_rbtree</tt><big>(</big>void* (*key_function_pointer)(struct <a class="reference internal" href="#stree_node" title="stree_node">stree_node</a>*<em> node)</em>, int64_t (*compare_function_pointer)(void*<em> keyA</em>, void*<em> keyB)</em><big>)</big><a class="headerlink" href="#new_rbtree" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="xref c c-member docutils literal"><span class="pre">key_function_pointer</span></tt> A function that should return the address of the node&#8217;s key.</p>
<p><tt class="xref c c-member docutils literal"><span class="pre">compare_function_pointer</span></tt> A function that should compare two keys and return values as described above. It receives the addresses of each key.</p>
<p>This function creates an rbtree, which sorts the data according to the given functions. The following example shows how to create an rbtree to store integers.</p>
<p>Example:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &quot;rbtree.h&quot;</span>

<span class="kt">void</span><span class="o">*</span> <span class="n">key_address</span><span class="p">(</span><span class="n">tree_node</span><span class="o">*</span> <span class="n">node</span><span class="p">){</span>
   <span class="k">return</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int64_t</span> <span class="n">compare_integers</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">keyA</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">keyB</span><span class="p">){</span>
   <span class="k">return</span> <span class="o">*</span><span class="p">((</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">keyA</span><span class="p">)</span> <span class="o">-</span> <span class="o">*</span><span class="p">((</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">keyB</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
   <span class="n">tree_root</span><span class="o">*</span> <span class="n">rbtree</span> <span class="o">=</span> <span class="n">new_rbtree</span><span class="p">(</span><span class="o">&amp;</span> <span class="n">key_address</span><span class="p">,</span> <span class="o">&amp;</span> <span class="n">compare_integers</span><span class="p">);</span>
   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>You may compile it with</p>
<div class="highlight-bash"><div class="highlight"><pre>gcc -o <span class="nb">test</span> &lt;above_source_file&gt; -I&lt;folder path where rbtree.h is kept&gt;
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="rb_tree_insert">
void* <tt class="descname">rb_tree_insert</tt><big>(</big><a class="reference internal" href="#tree_root" title="tree_root">tree_root</a>*<em> root</em>, void*<em> node</em><big>)</big><a class="headerlink" href="#rb_tree_insert" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="xref c c-member docutils literal"><span class="pre">root</span></tt> A pointer to the tree root where to insert the data represented by <tt class="docutils literal"><span class="pre">node</span></tt>.</p>
<p><tt class="xref c c-member docutils literal"><span class="pre">node</span></tt> A pointer to the data, which will be inserted in the tree.</p>
<p>As the name implies this function inserts data into the rbtree. In the eventuality that the inserted value is already in the tree, it will be replaced and a pointer to the older value is returned. This is done so the user can free the space stored by that data. The following example shows how to insert integers in an rbtree.</p>
<p>Example:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &quot;rbtree.h&quot;</span>

<span class="kt">void</span><span class="o">*</span> <span class="n">key_address</span><span class="p">(</span><span class="n">tree_node</span><span class="o">*</span> <span class="n">node</span><span class="p">){</span>
   <span class="k">return</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int64_t</span> <span class="n">compare_integers</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">keyA</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">keyB</span><span class="p">){</span>
   <span class="k">return</span> <span class="o">*</span><span class="p">((</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">keyA</span><span class="p">)</span> <span class="o">-</span> <span class="o">*</span><span class="p">((</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">keyB</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
   <span class="n">tree_root</span><span class="o">*</span> <span class="n">rbtree</span> <span class="o">=</span> <span class="n">new_rbtree</span><span class="p">(</span><span class="o">&amp;</span> <span class="n">key_address</span><span class="p">,</span> <span class="o">&amp;</span> <span class="n">compare_integers</span><span class="p">);</span>
   <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">9</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>

   <span class="n">rb_tree_insert</span><span class="p">(</span><span class="n">rbtree</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>
   <span class="n">rb_tree_insert</span><span class="p">(</span><span class="n">rbtree</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
   <span class="n">rb_tree_insert</span><span class="p">(</span><span class="n">rbtree</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">);</span>
   <span class="kt">int</span> <span class="n">older</span> <span class="o">=</span> <span class="o">*</span><span class="p">((</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">rb_tree_insert</span><span class="p">(</span><span class="n">rbtree</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">d</span><span class="p">));</span>

   <span class="c1">//don&#39;t free older because it was &quot;alloched&quot; by the compiler.</span>
   <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Found a %d already stored in the tree.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">older</span><span class="p">);</span>

   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>You may compile it with</p>
<div class="highlight-bash"><div class="highlight"><pre>gcc -o <span class="nb">test</span> &lt;above_source_file&gt; -I&lt;folder path where rbtree.h is kept&gt;
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="rb_tree_delete">
void* <tt class="descname">rb_tree_delete</tt><big>(</big><a class="reference internal" href="#tree_root" title="tree_root">tree_root</a>*<em> root</em>, void*<em> key</em><big>)</big><a class="headerlink" href="#rb_tree_delete" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="xref c c-member docutils literal"><span class="pre">root</span></tt> A pointer to the tree root where to delete the data with key pointed by <tt class="docutils literal"><span class="pre">key</span></tt>.</p>
<p><tt class="xref c c-member docutils literal"><span class="pre">key</span></tt> A pointer to the key of the node to be deleted.</p>
<p>This function deletes a node from an rbtree. If a node with a key equal to the one pointed by <tt class="docutils literal"><span class="pre">key</span></tt> does not exist, NULL will be return. However, if such a node is found, then a pointer to the data is returned. This is done so the user can free the space used by that data. The following example shows how to use this function on an rbtree that stores integers.</p>
<p>Example:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &quot;rbtree.h&quot;</span>

<span class="kt">void</span><span class="o">*</span> <span class="n">key_address</span><span class="p">(</span><span class="n">tree_node</span><span class="o">*</span> <span class="n">node</span><span class="p">){</span>
   <span class="k">return</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int64_t</span> <span class="n">compare_integers</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">keyA</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">keyB</span><span class="p">){</span>
   <span class="k">return</span> <span class="o">*</span><span class="p">((</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">keyA</span><span class="p">)</span> <span class="o">-</span> <span class="o">*</span><span class="p">((</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">keyB</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
   <span class="n">tree_root</span><span class="o">*</span> <span class="n">rbtree</span> <span class="o">=</span> <span class="n">new_rbtree</span><span class="p">(</span><span class="o">&amp;</span> <span class="n">key_address</span><span class="p">,</span> <span class="o">&amp;</span> <span class="n">compare_integers</span><span class="p">);</span>
   <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">9</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>

   <span class="n">rb_tree_insert</span><span class="p">(</span><span class="n">rbtree</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>
   <span class="n">rb_tree_insert</span><span class="p">(</span><span class="n">rbtree</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
   <span class="n">rb_tree_insert</span><span class="p">(</span><span class="n">rbtree</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">);</span>

   <span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">stored</span><span class="p">;</span>
   <span class="n">stored</span> <span class="o">=</span> <span class="o">*</span><span class="p">((</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">rb_tree_delete</span><span class="p">(</span><span class="n">rbtree</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">d</span><span class="p">));</span>

   <span class="c1">//don&#39;t free stored because it was &quot;alloched&quot; by the compiler.</span>
   <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Found a %d stored in the tree.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">stored</span><span class="p">);</span>

   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>You may compile it with</p>
<div class="highlight-bash"><div class="highlight"><pre>gcc -o <span class="nb">test</span> &lt;above_source_file&gt; -I&lt;folder path where rbtree.h is kept&gt;
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="search_rbtree">
void* <tt class="descname">search_rbtree</tt><big>(</big><a class="reference internal" href="#tree_root" title="tree_root">tree_root</a><em> root</em>, void*<em> key</em><big>)</big><a class="headerlink" href="#search_rbtree" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="xref c c-member docutils literal"><span class="pre">root</span></tt> The root of the tree where to perform the search.</p>
<p><tt class="xref c c-member docutils literal"><span class="pre">key</span></tt> A pointer to the key of the node to be searched.</p>
<p>This function searchs an rbtree for a node. It returns NULL if nothing is found, or the data stored in the tree with a key equal to the value pointed by <tt class="docutils literal"><span class="pre">key</span></tt>. The following example shows how to search a tree that stores integers.</p>
<p>Example:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &quot;rbtree.h&quot;</span>

<span class="kt">void</span><span class="o">*</span> <span class="n">key_address</span><span class="p">(</span><span class="n">tree_node</span><span class="o">*</span> <span class="n">node</span><span class="p">){</span>
   <span class="k">return</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int64_t</span> <span class="n">compare_integers</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">keyA</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">keyB</span><span class="p">){</span>
   <span class="k">return</span> <span class="o">*</span><span class="p">((</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">keyA</span><span class="p">)</span> <span class="o">-</span> <span class="o">*</span><span class="p">((</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">keyB</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
   <span class="n">tree_root</span><span class="o">*</span> <span class="n">rbtree</span> <span class="o">=</span> <span class="n">new_rbtree</span><span class="p">(</span><span class="o">&amp;</span> <span class="n">key_address</span><span class="p">,</span> <span class="o">&amp;</span> <span class="n">compare_integers</span><span class="p">);</span>
   <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">9</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>

   <span class="n">rb_tree_insert</span><span class="p">(</span><span class="n">rbtree</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>
   <span class="n">rb_tree_insert</span><span class="p">(</span><span class="n">rbtree</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
   <span class="n">rb_tree_insert</span><span class="p">(</span><span class="n">rbtree</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">);</span>

   <span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">stored</span><span class="p">;</span>
   <span class="n">stored</span> <span class="o">=</span> <span class="o">*</span><span class="p">((</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">search_rbtree</span><span class="p">(</span><span class="o">*</span><span class="n">rbtree</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">d</span><span class="p">));</span>

   <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Found a %d stored in the tree.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">stored</span><span class="p">);</span>

   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>You may compile it with</p>
<div class="highlight-bash"><div class="highlight"><pre>gcc -o <span class="nb">test</span> &lt;above_source_file&gt; -I&lt;folder path where rbtree.h is kept&gt;
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="destroy_rbtree">
void <tt class="descname">destroy_rbtree</tt><big>(</big><a class="reference internal" href="#tree_root" title="tree_root">tree_root</a>*<em> root</em><big>)</big><a class="headerlink" href="#destroy_rbtree" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="xref c c-member docutils literal"><span class="pre">root</span></tt> A pointer to the tree to be destroyed.</p>
<p>This function destroys an rbtree. Note that this doesn&#8217;t free the user stored data. The following example shows how to use this in a tree that stores integers.</p>
<p>Example:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &quot;rbtree.h&quot;</span>

<span class="kt">void</span><span class="o">*</span> <span class="n">key_address</span><span class="p">(</span><span class="n">tree_node</span><span class="o">*</span> <span class="n">node</span><span class="p">){</span>
   <span class="k">return</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int64_t</span> <span class="n">compare_integers</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">keyA</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">keyB</span><span class="p">){</span>
   <span class="k">return</span> <span class="o">*</span><span class="p">((</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">keyA</span><span class="p">)</span> <span class="o">-</span> <span class="o">*</span><span class="p">((</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">keyB</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
   <span class="n">tree_root</span><span class="o">*</span> <span class="n">rbtree</span> <span class="o">=</span> <span class="n">new_rbtree</span><span class="p">(</span><span class="o">&amp;</span> <span class="n">key_address</span><span class="p">,</span> <span class="o">&amp;</span> <span class="n">compare_integers</span><span class="p">);</span>
   <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">9</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>

   <span class="n">rb_tree_insert</span><span class="p">(</span><span class="n">rbtree</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>
   <span class="n">rb_tree_insert</span><span class="p">(</span><span class="n">rbtree</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
   <span class="n">rb_tree_insert</span><span class="p">(</span><span class="n">rbtree</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">);</span>

   <span class="n">destroy_rbtree</span><span class="p">(</span><span class="n">rbtree</span><span class="p">);</span>
   <span class="c1">//We do not need to free the stored data because it was &quot;alloched&quot; by the compiler.</span>

   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>You may compile it with</p>
<div class="highlight-bash"><div class="highlight"><pre>gcc -o <span class="nb">test</span> &lt;above_source_file&gt; -I&lt;folder path where rbtree.h is kept&gt;
</pre></div>
</div>
<p>Notice that running the command</p>
<div class="highlight-bash"><div class="highlight"><pre>valgrind --show-reachable<span class="o">=</span>yes --leak-check<span class="o">=</span>full ./test
</pre></div>
</div>
<p>produces the ouput:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="o">==</span><span class="mi">1188</span><span class="o">==</span> <span class="n">HEAP</span> <span class="n">SUMMARY</span><span class="o">:</span>
<span class="o">==</span><span class="mi">1188</span><span class="o">==</span>     <span class="n">in</span> <span class="n">use</span> <span class="n">at</span> <span class="n">exit</span><span class="o">:</span> <span class="mi">0</span> <span class="n">bytes</span> <span class="n">in</span> <span class="mi">0</span> <span class="n">blocks</span>
<span class="o">==</span><span class="mi">1188</span><span class="o">==</span>   <span class="n">total</span> <span class="n">heap</span> <span class="n">usage</span><span class="o">:</span> <span class="mi">4</span> <span class="n">allocs</span><span class="p">,</span> <span class="mi">4</span> <span class="n">frees</span><span class="p">,</span> <span class="mi">72</span> <span class="n">bytes</span> <span class="n">allocated</span>
<span class="o">==</span><span class="mi">1188</span><span class="o">==</span>
<span class="o">==</span><span class="mi">1188</span><span class="o">==</span> <span class="n">All</span> <span class="n">heap</span> <span class="n">blocks</span> <span class="n">were</span> <span class="n">freed</span> <span class="o">--</span> <span class="n">no</span> <span class="n">leaks</span> <span class="n">are</span> <span class="n">possible</span>
</pre></div>
</div>
<p>Which means that there are no memory leaks and you should always use this function to free the space stored by any rbtree you use.</p>
</dd></dl>

<dl class="function">
<dt id="new_tree_iterator">
<a class="reference internal" href="#tree_iterator" title="tree_iterator">tree_iterator</a>* <tt class="descname">new_tree_iterator</tt><big>(</big><a class="reference internal" href="#tree_root" title="tree_root">tree_root</a>*<em> root</em><big>)</big><a class="headerlink" href="#new_tree_iterator" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="xref c c-member docutils literal"><span class="pre">root</span></tt> A pointer to a tree root, which the iteration will be performed.</p>
<p>This function creates an iterator to an rbtree. Note that when you create an iterator, you should not insert or delete nodes from the tree before the iteration is over. Otherwise, the behaviour of the program will be unpredictable. It returns pointer to the created iterator. The following example shows how to create an iterator for a tree that stores integers.</p>
<p>Example:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &quot;rbtree.h&quot;</span>

<span class="kt">void</span><span class="o">*</span> <span class="n">key_address</span><span class="p">(</span><span class="n">tree_node</span><span class="o">*</span> <span class="n">node</span><span class="p">){</span>
   <span class="k">return</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int64_t</span> <span class="n">compare_integers</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">keyA</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">keyB</span><span class="p">){</span>
   <span class="k">return</span> <span class="o">*</span><span class="p">((</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">keyA</span><span class="p">)</span> <span class="o">-</span> <span class="o">*</span><span class="p">((</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">keyB</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
   <span class="n">tree_root</span><span class="o">*</span> <span class="n">rbtree</span> <span class="o">=</span> <span class="n">new_rbtree</span><span class="p">(</span><span class="o">&amp;</span> <span class="n">key_address</span><span class="p">,</span> <span class="o">&amp;</span> <span class="n">compare_integers</span><span class="p">);</span>
   <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">9</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>

   <span class="n">rb_tree_insert</span><span class="p">(</span><span class="n">rbtree</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>
   <span class="n">rb_tree_insert</span><span class="p">(</span><span class="n">rbtree</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
   <span class="n">rb_tree_insert</span><span class="p">(</span><span class="n">rbtree</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">);</span>

   <span class="n">tree_iterator</span><span class="o">*</span> <span class="n">it</span> <span class="o">=</span> <span class="n">new_tree_iterator</span><span class="p">(</span><span class="n">rbtree</span><span class="p">);</span>

   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>You may compile it with</p>
<div class="highlight-bash"><div class="highlight"><pre>gcc -o <span class="nb">test</span> &lt;above_source_file&gt; -I&lt;folder path where rbtree.h is kept&gt;
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="tree_iterator_has_next">
uint8_t <tt class="descname">tree_iterator_has_next</tt><big>(</big><a class="reference internal" href="#tree_iterator" title="tree_iterator">tree_iterator</a>*<em> it</em><big>)</big><a class="headerlink" href="#tree_iterator_has_next" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="xref c c-member docutils literal"><span class="pre">it</span></tt> A tree iterator created by calling <a class="reference internal" href="#new_tree_iterator" title="new_tree_iterator"><tt class="xref c c-func docutils literal"><span class="pre">new_tree_iterator()</span></tt></a>.</p>
<p>This function returns 1 if there are more elements in the tree to be iterated. The following code shows a simple usage of this function.</p>
<p>Example:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &quot;rbtree.h&quot;</span>

<span class="kt">void</span><span class="o">*</span> <span class="n">key_address</span><span class="p">(</span><span class="n">tree_node</span><span class="o">*</span> <span class="n">node</span><span class="p">){</span>
   <span class="k">return</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int64_t</span> <span class="n">compare_integers</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">keyA</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">keyB</span><span class="p">){</span>
   <span class="k">return</span> <span class="o">*</span><span class="p">((</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">keyA</span><span class="p">)</span> <span class="o">-</span> <span class="o">*</span><span class="p">((</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">keyB</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
   <span class="n">tree_root</span><span class="o">*</span> <span class="n">rbtree</span> <span class="o">=</span> <span class="n">new_rbtree</span><span class="p">(</span><span class="o">&amp;</span> <span class="n">key_address</span><span class="p">,</span> <span class="o">&amp;</span> <span class="n">compare_integers</span><span class="p">);</span>
   <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">9</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>

   <span class="n">rb_tree_insert</span><span class="p">(</span><span class="n">rbtree</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>
   <span class="n">rb_tree_insert</span><span class="p">(</span><span class="n">rbtree</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
   <span class="n">rb_tree_insert</span><span class="p">(</span><span class="n">rbtree</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">);</span>

   <span class="n">tree_iterator</span><span class="o">*</span> <span class="n">it</span> <span class="o">=</span> <span class="n">new_tree_iterator</span><span class="p">(</span><span class="n">rbtree</span><span class="p">);</span>

   <span class="k">if</span><span class="p">(</span><span class="n">tree_iterator_has_next</span><span class="p">(</span><span class="n">it</span><span class="p">))</span>
     <span class="n">printf</span><span class="p">(</span><span class="s">&quot;There are still elements to be iterated.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>You may compile it with</p>
<div class="highlight-bash"><div class="highlight"><pre>gcc -o <span class="nb">test</span> &lt;above_source_file&gt; -I&lt;folder path where rbtree.h is kept&gt;
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="tree_iterator_next">
void* <tt class="descname">tree_iterator_next</tt><big>(</big><a class="reference internal" href="#tree_iterator" title="tree_iterator">tree_iterator</a>*<em> it</em><big>)</big><a class="headerlink" href="#tree_iterator_next" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="xref c c-member docutils literal"><span class="pre">it</span></tt> A tree iterator created by calling <a class="reference internal" href="#new_tree_iterator" title="new_tree_iterator"><tt class="xref c c-func docutils literal"><span class="pre">new_tree_iterator()</span></tt></a>.</p>
<p>This functions returns the current element pointed by iterator <tt class="docutils literal"><span class="pre">it</span></tt> and advances to the next element in the iteration. This function should be used with <a class="reference internal" href="#tree_iterator_has_next" title="tree_iterator_has_next"><tt class="xref c c-func docutils literal"><span class="pre">tree_iterator_has_next()</span></tt></a>. Note that there is <strong>no</strong> guaranty about the order of iteration. The following code shows how to use it.</p>
<p>Example:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &quot;rbtree.h&quot;</span>

<span class="kt">void</span><span class="o">*</span> <span class="n">key_address</span><span class="p">(</span><span class="n">tree_node</span><span class="o">*</span> <span class="n">node</span><span class="p">){</span>
   <span class="k">return</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int64_t</span> <span class="n">compare_integers</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">keyA</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">keyB</span><span class="p">){</span>
   <span class="k">return</span> <span class="o">*</span><span class="p">((</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">keyA</span><span class="p">)</span> <span class="o">-</span> <span class="o">*</span><span class="p">((</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">keyB</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
   <span class="n">tree_root</span><span class="o">*</span> <span class="n">rbtree</span> <span class="o">=</span> <span class="n">new_rbtree</span><span class="p">(</span><span class="o">&amp;</span> <span class="n">key_address</span><span class="p">,</span> <span class="o">&amp;</span> <span class="n">compare_integers</span><span class="p">);</span>
   <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">9</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>

   <span class="n">rb_tree_insert</span><span class="p">(</span><span class="n">rbtree</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>
   <span class="n">rb_tree_insert</span><span class="p">(</span><span class="n">rbtree</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
   <span class="n">rb_tree_insert</span><span class="p">(</span><span class="n">rbtree</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">);</span>

   <span class="n">tree_iterator</span><span class="o">*</span> <span class="n">it</span> <span class="o">=</span> <span class="n">new_tree_iterator</span><span class="p">(</span><span class="n">rbtree</span><span class="p">);</span>

   <span class="k">while</span><span class="p">(</span><span class="n">tree_iterator_has_next</span><span class="p">(</span><span class="n">it</span><span class="p">)){</span>
     <span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="o">*</span><span class="p">((</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">tree_iterator_next</span><span class="p">(</span><span class="n">it</span><span class="p">));</span>
     <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">d</span><span class="p">);</span>
   <span class="p">}</span>
   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>You may compile it with</p>
<div class="highlight-bash"><div class="highlight"><pre>gcc -o <span class="nb">test</span> &lt;above_source_file&gt; -I&lt;folder path where rbtree.h is kept&gt;
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="destroy_iterator">
void <tt class="descname">destroy_iterator</tt><big>(</big><a class="reference internal" href="#tree_iterator" title="tree_iterator">tree_iterator</a>*<em> it</em><big>)</big><a class="headerlink" href="#destroy_iterator" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="xref c c-member docutils literal"><span class="pre">it</span></tt> A tree iterator created by calling <a class="reference internal" href="#new_tree_iterator" title="new_tree_iterator"><tt class="xref c c-func docutils literal"><span class="pre">new_tree_iterator()</span></tt></a>.</p>
<p>This function frees the iterator pointed by <tt class="docutils literal"><span class="pre">it</span></tt>. The following example shows how to use it.</p>
<p>Example:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &quot;rbtree.h&quot;</span>

<span class="kt">void</span><span class="o">*</span> <span class="n">key_address</span><span class="p">(</span><span class="n">tree_node</span><span class="o">*</span> <span class="n">node</span><span class="p">){</span>
   <span class="k">return</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int64_t</span> <span class="n">compare_integers</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">keyA</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">keyB</span><span class="p">){</span>
   <span class="k">return</span> <span class="o">*</span><span class="p">((</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">keyA</span><span class="p">)</span> <span class="o">-</span> <span class="o">*</span><span class="p">((</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">keyB</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
   <span class="n">tree_root</span><span class="o">*</span> <span class="n">rbtree</span> <span class="o">=</span> <span class="n">new_rbtree</span><span class="p">(</span><span class="o">&amp;</span> <span class="n">key_address</span><span class="p">,</span> <span class="o">&amp;</span> <span class="n">compare_integers</span><span class="p">);</span>
   <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">9</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>

   <span class="n">rb_tree_insert</span><span class="p">(</span><span class="n">rbtree</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>
   <span class="n">rb_tree_insert</span><span class="p">(</span><span class="n">rbtree</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
   <span class="n">rb_tree_insert</span><span class="p">(</span><span class="n">rbtree</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">);</span>

   <span class="n">tree_iterator</span><span class="o">*</span> <span class="n">it</span> <span class="o">=</span> <span class="n">new_tree_iterator</span><span class="p">(</span><span class="n">rbtree</span><span class="p">);</span>

   <span class="k">while</span><span class="p">(</span><span class="n">tree_iterator_has_next</span><span class="p">(</span><span class="n">it</span><span class="p">)){</span>
     <span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="o">*</span><span class="p">((</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">tree_iterator_next</span><span class="p">(</span><span class="n">it</span><span class="p">));</span>
     <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">d</span><span class="p">);</span>
   <span class="p">}</span>
   <span class="n">destroy_iterator</span><span class="p">(</span><span class="n">it</span><span class="p">);</span>

   <span class="n">destroy_rbtree</span><span class="p">(</span><span class="n">rbtree</span><span class="p">);</span>
   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>You may compile it with</p>
<div class="highlight-bash"><div class="highlight"><pre>gcc -o <span class="nb">test</span> &lt;above_source_file&gt; -I&lt;folder path where rbtree.h is kept&gt;
</pre></div>
</div>
<div class="highlight-bash"><div class="highlight"><pre>valgrind --show-reachable<span class="o">=</span>yes --leak-check<span class="o">=</span>full ./test
</pre></div>
</div>
<p>produces the ouput:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="o">==</span><span class="mi">4432</span><span class="o">==</span> <span class="n">HEAP</span> <span class="n">SUMMARY</span><span class="o">:</span>
<span class="o">==</span><span class="mi">4432</span><span class="o">==</span>     <span class="n">in</span> <span class="n">use</span> <span class="n">at</span> <span class="n">exit</span><span class="o">:</span> <span class="mi">0</span> <span class="n">bytes</span> <span class="n">in</span> <span class="mi">0</span> <span class="n">blocks</span>
<span class="o">==</span><span class="mi">4432</span><span class="o">==</span>   <span class="n">total</span> <span class="n">heap</span> <span class="n">usage</span><span class="o">:</span> <span class="mi">5</span> <span class="n">allocs</span><span class="p">,</span> <span class="mi">5</span> <span class="n">frees</span><span class="p">,</span> <span class="mi">76</span> <span class="n">bytes</span> <span class="n">allocated</span>
<span class="o">==</span><span class="mi">4432</span><span class="o">==</span>
<span class="o">==</span><span class="mi">4432</span><span class="o">==</span> <span class="n">All</span> <span class="n">heap</span> <span class="n">blocks</span> <span class="n">were</span> <span class="n">freed</span> <span class="o">--</span> <span class="n">no</span> <span class="n">leaks</span> <span class="n">are</span> <span class="n">possible</span>
</pre></div>
</div>
<p>Which means that there are no memory leaks and you should always use this function when iterating.</p>
</dd></dl>

</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Data Structures</a><ul>
<li><a class="reference internal" href="#generic-list">Generic List</a><ul>
<li><a class="reference internal" href="#function-description">Function description</a></li>
</ul>
</li>
<li><a class="reference internal" href="#generic-red-black-tree">Generic Red Black Tree</a><ul>
<li><a class="reference internal" href="#id1">Function description</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="../querying.html"
                        title="previous chapter">Querying</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="../macros.h.html"
                        title="next chapter">Special Macros</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../lxq_sources/data_structures/datastructures.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../macros.h.html" title="Special Macros"
             >next</a> |</li>
        <li class="right" >
          <a href="../querying.html" title="Querying"
             >previous</a> |</li>
        <li><a href="../index.html">libxmlquery v0.1.4 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2010, Frederico Gonçalves, Vasco Fernandes.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.0.4.
    </div>
  </body>
</html>